<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Main</title>
  <script src="main.js"></script>
  <style>
    body { margin: 0; background-color: #ffffff00 }
  </style>
</head>

<body>
  <script type="x-shader/x-vertex" id="vertexshader">
    out vec2 v_uv;
    uniform bool crunch;
    void main() {
      v_uv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      if (crunch) {
        float c = .5;
        gl_Position.x = round(gl_Position.x/c)*c;
        gl_Position.y = round(gl_Position.y/c)*c;
        //gl_Position.z = round(gl_Position.z/c)*c;
      }
    }
  </script>
  <script type="x-shader/x-fragment" id="fragmentshader">
    // The original materials provided by the GLTF loader correctly handle
    // the MASK mode transparency, even in tricky cases, but in order to
    // animate blinking we have to replace it with our own custom ShaderMaterial.
    // However, the default ShaderMaterial does not have the correct alpha
    // blending settings; by default, the alpha channel of the fragment shader
    // output is just ignored. Setting transparent = true on the material helps,
    // but does not work consistently, presumably due to polygon sorting issues.
    //
    // The only way I could get it to work was by calling discard
    // at the end of the fragment shader. If I had to guess, there must be some
    // logic that normally runs after the loader that checks if alphaTest is set
    // and sets up a shader under the hood that calls discard like we're doing
    // here.
    //
    // Of course, the most accurate thing would be to do polygon sorting like
    // the PSX does and then enable full alpha blending to faithfully
    // represent models like ClearAgumon and Datamon.
    in vec2 v_uv;
    uniform sampler2D monTexture;
    uniform float time;
    struct Blink {
      vec2 dest;
      vec2 dim;
      vec2 src1;
      vec2 src2;
      vec2 src3;
    };
    uniform Blink blinks[5];
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
      vec4 samp = texture2D(monTexture, v_uv);
      // For each of the up to 5 eye blink structures, if the UVs are in
      // the target region, offset the UVs to look up the source eye sprites
      // instead. The source sprite that is used depends on the time.
      for (int i = 0; i < 5; i++) {
        float sx = blinks[i].dest.x;
        float sy = blinks[i].dest.y;
        float ex = sx + blinks[i].dim.x;
        float ey = sy + blinks[i].dim.y;
        float vuvx = mod(v_uv.x, 0.125);
        float vuvy = mod(v_uv.y, 0.5);
        if (vuvx > 4.*sx && vuvy > sy && vuvx < 4.*ex && vuvy < ey) {
          vec2 offset = vec2(
            4.*blinks[i].src1.x - 4.*sx,
            blinks[i].src1.y - sy
          );
          if (mod(time, 3.0) > 2.9) {
            offset = vec2(
              4.*blinks[i].src2.x - 4.*sx,
              blinks[i].src2.y - sy
            );
          }
          if (mod(time, 3.0) > 2.95) {
            offset = vec2(
              4.*blinks[i].src3.x - 4.*sx,
              blinks[i].src3.y - sy
            );
          }
          samp = texture2D(monTexture, v_uv + offset);
        }
      }
      gl_FragColor = gl_FragColor * samp;
      if (gl_FragColor.a == 0.0) {
        discard;
      } else {
        // Myotismon apparently has a 50% opacity head and torso.
        // Not sure why. For now I'm removing semi-transparency
        gl_FragColor.a = 1.0;
      }
    }
  </script>
  <div id="myapp"></div>
  <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.140.2/build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from '/vendor/GLTFLoader.js';
    let r = 0;
    let monIndex = 0;
    let doCrunch = false;
    let scene;

    let state = {
      mons: [],
    };

    for (const [key, value] of new URLSearchParams(window.location.search)) {
      if (key == "mon") {
        let index = parseInt(value);
        if (!isNaN(index)) {
          monIndex = index;
        }
      }
      if (key == "crunch") {
        doCrunch = true;
      }
    }

    function convertGltfAssetTexture(gltfScene) {
      let offscreenCanvas = new OffscreenCanvas(1024, 1024);
      let offscreenCanvasCtx = offscreenCanvas.getContext("2d");

      let gotTexture = false;
      gltfScene.traverse(function(child) {
        if (child.isMesh) {
          let material = child.material;
          if (!gotTexture) {
            let imageBitmap = material.map.source.data;
            offscreenCanvasCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            offscreenCanvasCtx.drawImage(imageBitmap, 0, 0);
            gotTexture = true;
          }
        }
      })

      let canvasTexture = new THREE.CanvasTexture(offscreenCanvas);
      canvasTexture.flipY = false;
      canvasTexture.magFilter = 1003;
      canvasTexture.minFilter = 1003;


      let shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
          crunch: { value: doCrunch },
          time: { value: 1.0 },
          monTexture: { value: canvasTexture },
          blinks: {
            value: [
              {
                dest: new THREE.Vector2(),
                dim: new THREE.Vector2(),
                src1: new THREE.Vector2(),
                src2: new THREE.Vector2(),
                src3: new THREE.Vector2(),
              },
              {
                dest: new THREE.Vector2(),
                dim: new THREE.Vector2(),
                src1: new THREE.Vector2(),
                src2: new THREE.Vector2(),
                src3: new THREE.Vector2(),
              },
              {
                dest: new THREE.Vector2(),
                dim: new THREE.Vector2(),
                src1: new THREE.Vector2(),
                src2: new THREE.Vector2(),
                src3: new THREE.Vector2(),
              },
              {
                dest: new THREE.Vector2(),
                dim: new THREE.Vector2(),
                src1: new THREE.Vector2(),
                src2: new THREE.Vector2(),
                src3: new THREE.Vector2(),
              },
              {
                dest: new THREE.Vector2(),
                dim: new THREE.Vector2(),
                src1: new THREE.Vector2(),
                src2: new THREE.Vector2(),
                src3: new THREE.Vector2(),
              },
            ],
          }
        },
        vertexShader: document.getElementById('vertexshader').textContent,
        fragmentShader: document.getElementById('fragmentshader').textContent,
      });

      return {
        shaderMaterial,
        canvasTexture,
      };
    }

    let gltfLoader = new GLTFLoader();

    let mut = 0;

    async function loadModel(scene, monIndex) {
      await fetch('model/' + monIndex, { cache: "force-cache" }).then(response => {
        return response.arrayBuffer();
      }).then(function(buffer) {
        gltfLoader.parse(
          buffer,
          null,
          function (loadedAsset) {
            let mon = loadedAsset.scene;

            // find the texture in the gltf asset and convert it into a shader
            // material
            let { shaderMaterial, canvasTexture } =
              convertGltfAssetTexture(mon);

            mon.traverse(function(child) {
              if (child.isMesh) {
                child.material = shaderMaterial;
              }
            });

            let blinks = loadedAsset.userData.blink;
            for (let i = 0; i < blinks.length; i++) {
              // The blink values are in units of pixels, so we have to scale
              // them to 0-1 using the dimensions of the texture (1024x1024).
              shaderMaterial.uniforms.blinks.value[i] =
                {
                  dest: new THREE.Vector2(blinks[i][0]/1024, blinks[i][1]/1024),
                  dim: new THREE.Vector2(blinks[i][2]/1024, blinks[i][3]/1024),
                  src1: new THREE.Vector2(blinks[i][4]/1024, blinks[i][5]/1024),
                  src2: new THREE.Vector2(blinks[i][6]/1024, blinks[i][7]/1024),
                  src3: new THREE.Vector2(blinks[i][8]/1024, blinks[i][9]/1024)
                };
            }

            let assetMixer = new THREE.AnimationMixer(loadedAsset.scene);
            assetMixer.clipAction(loadedAsset.animations[0]).play();

            mon.position.x = THREE.MathUtils.randFloat(-6, 6);
            mon.position.z = THREE.MathUtils.randFloat(-10, 10);

            state.mons.push({
              asset: mon,
              position: new THREE.Vector2(0, 0),
              material: shaderMaterial,
              r: 0,
              mixer: assetMixer,
              aiState: "idle",
              animations: loadedAsset.animations,
              stateTime: 0,
              velocityUp: 0,
              jumpsLeft: 0,
              speed: THREE.MathUtils.randFloat(0.75, 1.25),
              energy: THREE.MathUtils.randFloat(0.75, 1.25),
            });
            scene.add(mon);
          },
          function (error) {
            alert(error);
          }
        );
      });
    }

    function setupThreeJSScene() {
      console.log("inited scene");
      scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        10,
        window.innerWidth / window.innerHeight,
        0.1,
        1000);
      const renderer = new THREE.WebGLRenderer({
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);

      renderer.gammaOutput = true;
      renderer.gammaFactor = 2.2;

      document.body.appendChild(renderer.domElement);
      const geometry = new THREE.BoxGeometry();
      const material = new THREE.MeshBasicMaterial({color : 0x00ff00});
      const cube = new THREE.Mesh(geometry, material);
      const light = new THREE.AmbientLight(0xffffff);
      const planeGeo = new THREE.PlaneGeometry(100, 100);
      const plane = new THREE.Mesh(planeGeo, material);
      plane.position.y = 0;
      plane.rotation.y = 3.1415;
      plane.rotation.x = 3.1415/2;
      //scene.add(plane);
      scene.add(light);
      camera.position.y = 0.4;
      const clock = new THREE.Clock();
      function animate() {
        let delta = clock.getDelta();
        camera.position.z = -30.0;
        camera.position.x = 0.0;
        camera.position.y = 15.0;
        camera.lookAt(0, 0, 0);

        for (let i = 0; i < state.mons.length; i++) {
          if (state.mons[i].material) {
            state.mons[i].material.uniforms.crunch.value = doCrunch;
            state.mons[i].material.uniforms.time.value = state.mons[i].r;
            state.mons[i].asset.rotation.y = 0.5 * state.mons[i].r;
          }
          if (state.mons[i].mixer) {
            state.mons[i].mixer.update(delta * state.mons[i].speed);
          }
          if (state.mons[i].aiState == "jump") {
            if (state.mons[i].asset.position.y > 0) {
              state.mons[i].asset.position.y += delta * state.mons[i].velocityUp;
              state.mons[i].velocityUp -= 15 * delta;
            }
            if (state.mons[i].asset.position.y <= 0) {
              state.mons[i].asset.position.y = 0;
              state.mons[i].velocityUp = 0;
              if (state.mons[i].jumpsLeft > 0) {
                state.mons[i].velocityUp = 2;
                state.mons[i].jumpsLeft = 0;
              }
            }
          }
          if (state.mons[i].aiState == "idle") {
          }
          if (state.mons[i].aiState == "run") {
            state.mons[i].r += state.mons[i].heading * 2. * delta;
            let forward = new THREE.Vector3(0.0, 0.0, -1.0)
              .applyEuler(state.mons[i].asset.rotation);
            state.mons[i].asset.position.add(
              forward.multiplyScalar(state.mons[i].energy * 1.5 * delta)
            );
          }
          state.mons[i].stateTime -= delta;

          // State transition
          if (state.mons[i].stateTime <= 0) {
            if (state.mons[i].aiState == "run") {
              let shouldTransition = THREE.MathUtils.randFloat(0, 1) < 0.6;
              if (shouldTransition) {
                state.mons[i].aiState = "idle";
                state.mons[i].mixer.clipAction(state.mons[i].animations[0]).play();
                state.mons[i].mixer.clipAction(state.mons[i].animations[1]).stop();
                state.mons[i].stateTime =
                  (1/state.mons[i].energy) *
                  THREE.MathUtils.randFloat(1, 1.5) *
                  THREE.MathUtils.randFloat(1, 1.5) *
                  THREE.MathUtils.randFloat(1, 1.5);
              } else {
                state.mons[i].mixer.clipAction(state.mons[i].animations[1]).play();
                state.mons[i].mixer.clipAction(state.mons[i].animations[0]).stop();
                state.mons[i].stateTime =
                  THREE.MathUtils.randFloat(1, 2) *
                  THREE.MathUtils.randFloat(1, 2);
                state.mons[i].heading = THREE.MathUtils.randFloat(-1, 1);
              }
            } else if (state.mons[i].aiState == "idle") {
              let choice = THREE.MathUtils.randFloat(0, 1);
              if (choice < 0.1) {
                state.mons[i].aiState = "jump";
                state.mons[i].velocityUp = 2;
                state.mons[i].jumpsLeft = 2;
                state.mons[i].mixer.clipAction(state.mons[i].animations[0]).play();
                state.mons[i].mixer.clipAction(state.mons[i].animations[1]).stop();
                state.mons[i].stateTime = 2;
              } else if (choice < 0.9) {
                state.mons[i].aiState = "run";
                state.mons[i].mixer.clipAction(state.mons[i].animations[1]).play();
                state.mons[i].mixer.clipAction(state.mons[i].animations[0]).stop();
                state.mons[i].stateTime =
                  state.mons[i].energy *
                  THREE.MathUtils.randFloat(1, 2) *
                  THREE.MathUtils.randFloat(1, 2);
                state.mons[i].heading = THREE.MathUtils.randFloat(-1, 1);
              }
            } else if (state.mons[i].aiState == "jump") {
              if (THREE.MathUtils.randFloat(0, 1) < 0.9) {
                state.mons[i].aiState = "idle";
                state.mons[i].mixer.clipAction(state.mons[i].animations[0]).play();
                state.mons[i].mixer.clipAction(state.mons[i].animations[1]).stop();
                state.mons[i].stateTime =
                  THREE.MathUtils.randFloat(1, 1.5) *
                  THREE.MathUtils.randFloat(1, 1.5) *
                  THREE.MathUtils.randFloat(1, 1.5);
              }
            }
          }

          let boundX = 6;
          if (state.mons[i].asset.position.x > boundX) {
            state.mons[i].asset.position.x = -boundX;
          } else if (state.mons[i].asset.position.x < -boundX) {
            state.mons[i].asset.position.x = boundX;
          }

          let boundZ = 10;
          if (state.mons[i].asset.position.z > boundZ) {
            state.mons[i].asset.position.z = -boundZ;
          } else if (state.mons[i].asset.position.z < -boundZ) {
            state.mons[i].asset.position.z = boundZ;
          }
        }

        // handle collision
        //
        // n^2 complexity here is gross
        //
        // could use a grid system instead... whenever a monster moves, it
        // updates the grid with its new position, and then for each monster,
        // perform collision against monsters in same or neighboring cells
        //
        // grid cell width must not be less than the collision radius to ensure
        // that the monster's bounding circle does not overlap with monsters
        // outside of the neighboring cells
        for (let i = 0; i < state.mons.length; i++) {
          for (let j = i + 1; j < state.mons.length; j++) {
            let collisionRadius = 0.5;
            let dist = state.mons[i].asset.position.clone()
              .sub(state.mons[j].asset.position);
            if (dist.length() < collisionRadius) {
              let push = dist.clone().normalize()
                .multiplyScalar(collisionRadius)
                .sub(dist);
              state.mons[i].asset.position.add(push.clone().multiplyScalar(0.5));
              state.mons[j].asset.position.add(push.clone().multiplyScalar(-0.5));
            }
          }
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();
    }

    setupThreeJSScene();

    //let app = Elm.Main.init({
    //  node: document.getElementById('myapp'),
    //  flags: { initModel: monIndex, initCrunch: doCrunch }
    //});

    //app.ports.setCrunch.subscribe(function(b) {
    //  doCrunch = b;
    //});

    //app.ports.getModel.subscribe(async function(ix) {
    //  if (!gltfLoader) {
    //    alert("GLTF loader not yet ready");
    //    return;
    //  }
    //  if (!loadModel) {
    //    alert("loadModel not yet ready");
    //    return;
    //  }
    //  for (let i = 203; i < 260; i++) {
    //    await loadModel(scene, i);
    //  }
    //});
    for (let i = 203; i < 278; i++) {
      if (i >= 264 && i < 268) {
        continue;
      }
      await loadModel(scene, i);
    }
  </script>
</body>
</html>
