<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Main</title>
  <script src="main.js"></script>
  <style>
    body { margin: 0; background-color: #ffffff00 }
  </style>
</head>

<body>
  <script type="x-shader/x-vertex" id="vertexshader">
    out vec2 v_uv;
    uniform bool crunch;
    void main() {
      v_uv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      if (crunch) {
        float c = .5;
        gl_Position.x = round(gl_Position.x/c)*c;
        gl_Position.y = round(gl_Position.y/c)*c;
        //gl_Position.z = round(gl_Position.z/c)*c;
      }
    }
  </script>
  <script type="x-shader/x-fragment" id="fragmentshader">
    // The original materials provided by the GLTF loader correctly handle
    // the MASK mode transparency, even in tricky cases, but in order to
    // animate blinking we have to replace it with our own custom ShaderMaterial.
    // However, the default ShaderMaterial does not have the correct alpha
    // blending settings; by default, the alpha channel of the fragment shader
    // output is just ignored. Setting transparent = true on the material helps,
    // but does not work consistently, presumably due to polygon sorting issues.
    //
    // The only way I could get it to work was by calling discard
    // at the end of the fragment shader. If I had to guess, there must be some
    // logic that normally runs after the loader that checks if alphaTest is set
    // and sets up a shader under the hood that calls discard like we're doing
    // here.
    //
    // Of course, the most accurate thing would be to do polygon sorting like
    // the PSX does and then enable full alpha blending to faithfully
    // represent models like ClearAgumon and Datamon.
    in vec2 v_uv;
    uniform sampler2D monTexture;
    uniform float time;
    struct Blink {
      vec2 dest;
      vec2 dim;
      vec2 src1;
      vec2 src2;
      vec2 src3;
    };
    uniform Blink blinks[5];
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
      vec4 samp = texture2D(monTexture, v_uv);
      // For each of the up to 5 eye blink structures, if the UVs are in
      // the target region, offset the UVs to look up the source eye sprites
      // instead. The source sprite that is used depends on the time.
      for (int i = 0; i < 5; i++) {
        float sx = blinks[i].dest.x;
        float sy = blinks[i].dest.y;
        float ex = sx + blinks[i].dim.x;
        float ey = sy + blinks[i].dim.y;
        float vuvx = mod(v_uv.x, 0.125);
        float vuvy = mod(v_uv.y, 0.5);
        if (vuvx > 4.*sx && vuvy > sy && vuvx < 4.*ex && vuvy < ey) {
          vec2 offset = vec2(
            4.*blinks[i].src1.x - 4.*sx,
            blinks[i].src1.y - sy
          );
          if (mod(time, 3.0) > 2.9) {
            offset = vec2(
              4.*blinks[i].src2.x - 4.*sx,
              blinks[i].src2.y - sy
            );
          }
          if (mod(time, 3.0) > 2.95) {
            offset = vec2(
              4.*blinks[i].src3.x - 4.*sx,
              blinks[i].src3.y - sy
            );
          }
          samp = texture2D(monTexture, v_uv + offset);
        }
      }
      gl_FragColor = gl_FragColor * samp;
      if (gl_FragColor.a == 0.0) {
        discard;
      } else {
        // Myotismon apparently has a 50% opacity head and torso.
        // Not sure why. For now I'm removing semi-transparency
        gl_FragColor.a = 1.0;
      }
    }
  </script>
  <div id="myapp"></div>
  <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.140.2/build/three.module.js",
        "dat.gui": "https://unpkg.com/dat.gui@0.7.7/build/dat.gui.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import * as dat from 'dat.gui';
    import { GLTFLoader } from '/vendor/GLTFLoader.js';
    import { OrbitControls } from '/vendor/OrbitControls.js';
    let r = 0;
    let monIndex = 0;
    let doCrunch = false;
    let scene;
    let boundX = 2;
    let boundZ = 4;
    let cameraQuaternion = null;
    let cameraPosition = null;

    let state = {
      mons: [],
    };

    function encodeVector3(p) {
      return ""
        + p.x.toFixed(2) + "x"
        + p.y.toFixed(2) + "y"
        + p.z.toFixed(2) + "z";
    }

    function parseVector3(s) {
      let parts = s.split("x");
      if (parts.length != 2) {
        throw new Error("parseVector3: expected x component");
      }
      let x = parseFloat(parts[0]);
      parts = parts[1].split("y");
      if (parts.length != 2) {
        throw new Error("parseVector3: expected y component");
      }
      let y = parseFloat(parts[0]);
      parts = parts[1].split("z");
      if (parts.length != 2) {
        throw new Error("parseVector3: expected z component");
      }
      let z = parseFloat(parts[0]);
      if (parts[1] != "") {
        throw new Error("parseVector3: extra input");
      }
      return new THREE.Vector3(x, y, z);
    }

    function encodeQuaternion(q) {
      return ""
        + q.x.toFixed(2) + "i"
        + q.y.toFixed(2) + "j"
        + q.z.toFixed(2) + "k"
        + q.w.toFixed(2) + "w";
    }

    function parseQuaternion(s) {
      let parts = s.split("i");
      if (parts.length != 2) {
        throw new Error("parseQuaternion: expected i component");
      }
      let i = parseFloat(parts[0]);
      parts = parts[1].split("j");
      if (parts.length != 2) {
        throw new Error("parseQuaternion: expected j component");
      }
      let j = parseFloat(parts[0]);
      parts = parts[1].split("k");
      if (parts.length != 2) {
        throw new Error("parseQuaternion: expected k component");
      }
      let k = parseFloat(parts[0]);
      parts = parts[1].split("w");
      if (parts.length != 2) {
        throw new Error("parseQuaternion: expected w component");
      }
      let w = parseFloat(parts[0]);
      if (parts[1] != "") {
        throw new Error("parseQuaternion: extra input");
      }
      return new THREE.Quaternion(i, j, k, w);
    }

    for (const [key, value] of new URLSearchParams(window.location.search)) {
      if (key == "mon") {
        let index = parseInt(value);
        if (!isNaN(index)) {
          monIndex = index;
        }
      }
      if (key == "crunch") {
        doCrunch = true;
      }
      if (key == "boundX") {
        boundX = parseInt(value);
      }
      if (key == "boundZ") {
        boundZ = parseInt(value);
      }
      if (key == "cameraQ") {
        try {
          cameraQuaternion = parseQuaternion(value);
        } catch (e) {
          console.log("couldn't parse camera quaternion config: ", e);
        }
      }
      if (key == "cameraP") {
        try {
          cameraPosition = parseVector3(value);
        } catch (e) {
          console.log("couldn't parse camera position config: ", e);
        }
      }
    }

    function convertGltfAssetTexture(gltfScene) {
      let offscreenCanvas = new OffscreenCanvas(1024, 1024);
      let offscreenCanvasCtx = offscreenCanvas.getContext("2d");

      let gotTexture = false;
      gltfScene.traverse(function(child) {
        if (child.isMesh) {
          let material = child.material;
          if (!gotTexture) {
            let imageBitmap = material.map.source.data;
            offscreenCanvasCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            offscreenCanvasCtx.drawImage(imageBitmap, 0, 0);
            gotTexture = true;
          }
        }
      })

      let canvasTexture = new THREE.CanvasTexture(offscreenCanvas);
      canvasTexture.flipY = false;
      canvasTexture.magFilter = 1003;
      canvasTexture.minFilter = 1003;


      let shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
          crunch: { value: doCrunch },
          time: { value: 1.0 },
          monTexture: { value: canvasTexture },
          blinks: {
            value: [
              {
                dest: new THREE.Vector2(),
                dim: new THREE.Vector2(),
                src1: new THREE.Vector2(),
                src2: new THREE.Vector2(),
                src3: new THREE.Vector2(),
              },
              {
                dest: new THREE.Vector2(),
                dim: new THREE.Vector2(),
                src1: new THREE.Vector2(),
                src2: new THREE.Vector2(),
                src3: new THREE.Vector2(),
              },
              {
                dest: new THREE.Vector2(),
                dim: new THREE.Vector2(),
                src1: new THREE.Vector2(),
                src2: new THREE.Vector2(),
                src3: new THREE.Vector2(),
              },
              {
                dest: new THREE.Vector2(),
                dim: new THREE.Vector2(),
                src1: new THREE.Vector2(),
                src2: new THREE.Vector2(),
                src3: new THREE.Vector2(),
              },
              {
                dest: new THREE.Vector2(),
                dim: new THREE.Vector2(),
                src1: new THREE.Vector2(),
                src2: new THREE.Vector2(),
                src3: new THREE.Vector2(),
              },
            ],
          }
        },
        vertexShader: document.getElementById('vertexshader').textContent,
        fragmentShader: document.getElementById('fragmentshader').textContent,
      });

      return {
        shaderMaterial,
        canvasTexture,
      };
    }

    let gltfLoader = new GLTFLoader();

    let mut = 0;

    async function loadModel(scene, monIndex) {
      await fetch('model/' + monIndex, { cache: "force-cache" }).then(response => {
        return response.arrayBuffer();
      }).then(function(buffer) {
        gltfLoader.parse(
          buffer,
          null,
          function (loadedAsset) {
            let mon = loadedAsset.scene;

            // find the texture in the gltf asset and convert it into a shader
            // material
            let { shaderMaterial, canvasTexture } =
              convertGltfAssetTexture(mon);

            mon.traverse(function(child) {
              if (child.isMesh) {
                child.material = shaderMaterial;
              }
            });

            let blinks = loadedAsset.userData.blink;
            for (let i = 0; i < blinks.length; i++) {
              // The blink values are in units of pixels, so we have to scale
              // them to 0-1 using the dimensions of the texture (1024x1024).
              shaderMaterial.uniforms.blinks.value[i] =
                {
                  dest: new THREE.Vector2(blinks[i][0]/1024, blinks[i][1]/1024),
                  dim: new THREE.Vector2(blinks[i][2]/1024, blinks[i][3]/1024),
                  src1: new THREE.Vector2(blinks[i][4]/1024, blinks[i][5]/1024),
                  src2: new THREE.Vector2(blinks[i][6]/1024, blinks[i][7]/1024),
                  src3: new THREE.Vector2(blinks[i][8]/1024, blinks[i][9]/1024)
                };
            }

            let assetMixer = new THREE.AnimationMixer(loadedAsset.scene);
            assetMixer.clipAction(loadedAsset.animations[0]).play();

            mon.position.x = THREE.MathUtils.randFloat(-6, 6);
            mon.position.z = THREE.MathUtils.randFloat(-10, 10);

            // Assign index to all children so that we can find the mon in the
            // state after raycasting
            mon.traverse((x) => {
              x.userData.ix = state.mons.length;
            });

            state.mons.push({
              asset: mon,
              position: new THREE.Vector2(0, 0),
              material: shaderMaterial,
              r: 0,
              mixer: assetMixer,
              aiState: "idle",
              animations: loadedAsset.animations,
              stateTime: 0,
              velocityUp: 0,
              jumpsLeft: 0,
              speed: THREE.MathUtils.randFloat(0.75, 1.25),
              energy: THREE.MathUtils.randFloat(0.75, 1.25),
            });
            scene.add(mon);
          },
          function (error) {
            alert(error);
          }
        );
      });
    }

    function transitionStateToIdle(mon) {
      mon.aiState = "idle";
      mon.mixer.clipAction(mon.animations[0]).play();
      mon.mixer.clipAction(mon.animations[1]).stop();
      mon.stateTime =
        (1/mon.energy) *
        THREE.MathUtils.randFloat(1, 1.5) *
        THREE.MathUtils.randFloat(1, 1.5) *
        THREE.MathUtils.randFloat(1, 1.5);
    }

    function transitionStateToRun(mon) {
      mon.aiState = "run";
      mon.mixer.clipAction(mon.animations[1]).play();
      mon.mixer.clipAction(mon.animations[0]).stop();
      mon.stateTime =
        mon.energy *
        THREE.MathUtils.randFloat(1, 2) *
        THREE.MathUtils.randFloat(1, 2);
      mon.heading = THREE.MathUtils.randFloat(-1, 1);
    }

    function transitionStateToJump(mon) {
      if (mon.aiState != "jump") {
        mon.aiState = "jump";
        mon.velocityUp = 2;
        mon.jumpsLeft = 1;
        mon.jumping = true;
        mon.mixer.clipAction(mon.animations[0]).play();
        mon.mixer.clipAction(mon.animations[1]).stop();
        mon.stateTime = 3;
      }
    }

    function setupThreeJSScene() {
      console.log("inited scene");
      scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000);
      const renderer = new THREE.WebGLRenderer({
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);

      renderer.gammaOutput = true;
      renderer.gammaFactor = 2.2;

      document.body.appendChild(renderer.domElement);
      const geometry = new THREE.BoxGeometry();
      const material = new THREE.MeshBasicMaterial({color : 0x00ff00});
      const cube = new THREE.Mesh(geometry, material);
      const light = new THREE.AmbientLight(0xffffff);
      const planeGeo = new THREE.PlaneGeometry(100, 100);
      const plane = new THREE.Mesh(planeGeo, material);
      plane.position.y = 0;
      plane.rotation.y = 3.1415;
      plane.rotation.x = 3.1415/2;
      //scene.add(plane);
      scene.add(light);
      camera.position.y = 0.4;
      const clock = new THREE.Clock();

      let raycaster = new THREE.Raycaster();
      let pointer = new THREE.Vector2();

      window.addEventListener("click", (e) => {
        pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(scene.children);
        console.log(pointer);
        for (let i = 0; i < intersects.length; i++) {
          let hit = intersects[i].object;
          transitionStateToJump(state.mons[hit.userData.ix]);
        }
      });

      //let isMouseDown = false;

      //window.addEventListener("mousedown", (e) => {
      //  isMouseDown = true;
      //});

      //window.addEventListener("mouseup", (e) => {
      //  isMouseDown = false;
      //});

      //window.addEventListener("mousemove", (e) => {
      //  if (isMouseDown) {
      //    let eu = new THREE.Euler(e.movementX, e.movementY, 0);
      //    let q = new THREE.Quaternion();
      //    q.setFromEuler(eu);
      //    camera.
      //  }
      //});

      camera.position.z = -30.0;
      camera.position.x = 0.0;
      camera.position.y = 15.0;
      camera.lookAt(0, 0, 0);

      let controls = new OrbitControls(camera, renderer.domElement);

      if (cameraQuaternion != null) {
        console.log("loaded camera quaternion from url params");
        camera.setRotationFromQuaternion(cameraQuaternion);
        controls.update();
      }
      if (cameraPosition != null) {
        console.log("loaded camera position from url params");
        camera.position.copy(cameraPosition);
        controls.update();
      }

      //if (

      let guiState = {
        //q_i: 0.0,
        //q_j: 0.0,
        //q_k: 0.0,
        //q_w: 1.0,
        //normalize: function() {
        //  let q = new THREE.Quaternion(q_i, q_j, q_k, q_w);
        //  q.normalize();
        //  q_i = q.x;
        //  q_j = q.y;
        //  q_k = q.z;
        //  w_w = q.w;
        //},
        boundX: 2,
        boundZ: 2,
        exportCamera: function() {
          let baseUrl = window.location.origin;
          let p = encodeVector3(camera.position);
          let q = encodeQuaternion(camera.quaternion);
          let bX = boundX.toFixed(2);
          let bZ = boundZ.toFixed(2);
          let newPageUrl =
          `${baseUrl}?cameraP=${p}&cameraQ=${q}&boundX=${bX}&boundZ=${bZ}`; 
          alert("copied url to clipboard");
          navigator.clipboard
            .writeText(newPageUrl);
        }
      };
      // Creating a GUI with options.
      let gui = new dat.GUI({name: 'My GUI'});
      gui.add(guiState, 'boundX', 1, 10, 0.1)
        .onChange(function() { boundX = this.getValue() });
      gui.add(guiState, 'boundZ', 1, 10, 0.1)
        .onChange(function() { boundZ = this.getValue() });
      gui.add(guiState, 'exportCamera');

      function animate() {
        let delta = clock.getDelta();

        for (let i = 0; i < state.mons.length; i++) {
          if (state.mons[i].material) {
            state.mons[i].material.uniforms.crunch.value = doCrunch;
            state.mons[i].material.uniforms.time.value = state.mons[i].r;
            state.mons[i].asset.rotation.y = 0.5 * state.mons[i].r;
          }
          if (state.mons[i].mixer) {
            state.mons[i].mixer.update(delta * state.mons[i].speed);
          }

          if (state.mons[i].jumping) {
            state.mons[i].asset.position.y += delta * state.mons[i].velocityUp;
            state.mons[i].velocityUp -= 15 * delta;
          } else {
            state.mons[i].asset.position.y = 0;
            state.mons[i].velocityUp = 0;
          }

          if (state.mons[i].asset.position.y <= 0 && state.mons[i].velocityUp < 0) {
            state.mons[i].asset.position.y = 0;
            state.mons[i].velocityUp = 0;
            if (state.mons[i].jumpsLeft > 0) {
              state.mons[i].jumpsLeft -= 1;
              state.mons[i].velocityUp = 2;
              state.mons[i].jumping = true;
            } else {
              state.mons[i].jumping = false;
            }
          }

          if (state.mons[i].aiState == "idle") {
            if (state.mons[i].asset.position.y != 0) {
              console.log("uh oh");
            }
          }

          if (state.mons[i].aiState == "run") {
            if (state.mons[i].asset.position.y != 0) {
              console.log("uh oh");
            }
            state.mons[i].r += state.mons[i].heading * 2. * delta;
            let forward = new THREE.Vector3(0.0, 0.0, -1.0)
              .applyEuler(state.mons[i].asset.rotation);
            state.mons[i].asset.position.add(
              forward.multiplyScalar(state.mons[i].energy * 1.5 * delta)
            );
          }

          state.mons[i].stateTime -= delta;

          if (state.mons[i].aiState == "jump") {
            if (state.mons[i].jumping) {
              state.mons[i].stateTime = 100;
            } else {
              state.mons[i].stateTime = 0;
            }
          }

          // State transition
          if (state.mons[i].stateTime <= 0) {
            if (state.mons[i].aiState == "run") {
              let choice = THREE.MathUtils.randFloat(0, 1);
              if (choice < 0.6) {
                transitionStateToIdle(state.mons[i]);
              } else {
                transitionStateToRun(state.mons[i]);
              }
            } else if (state.mons[i].aiState == "idle") {
              let choice = THREE.MathUtils.randFloat(0, 1);
              if (choice < 0.2) {
                transitionStateToIdle(state.mons[i]);
              } else {
                transitionStateToRun(state.mons[i]);
              }
            } else if (state.mons[i].aiState == "jump") {
              let choice = THREE.MathUtils.randFloat(0, 1);
              if (choice < 0.5) {
                transitionStateToRun(state.mons[i]);
              } else {
                transitionStateToIdle(state.mons[i]);
              }
            }
          }

          // torus
          // let boundX = 6;
          // if (state.mons[i].asset.position.x > boundX) {
          //   state.mons[i].asset.position.x = -boundX;
          // } else if (state.mons[i].asset.position.x < -boundX) {
          //   state.mons[i].asset.position.x = boundX;
          // }

          // let boundZ = 10;
          // if (state.mons[i].asset.position.z > boundZ) {
          //   state.mons[i].asset.position.z = -boundZ;
          // } else if (state.mons[i].asset.position.z < -boundZ) {
          //   state.mons[i].asset.position.z = boundZ;
          // }
        }

        // handle collision
        //
        // n^2 complexity here is gross
        //
        // could use a grid system instead... whenever a monster moves, it
        // updates the grid with its new position, and then for each monster,
        // perform collision against monsters in same or neighboring cells
        //
        // grid cell width must not be less than the collision radius to ensure
        // that the monster's bounding circle does not overlap with monsters
        // outside of the neighboring cells
        for (let i = 0; i < state.mons.length; i++) {
          for (let j = i + 1; j < state.mons.length; j++) {
            let collisionRadius = 0.5;
            let dist = state.mons[i].asset.position.clone()
              .sub(state.mons[j].asset.position);
            if (dist.length() < collisionRadius) {
              let push = dist.clone().normalize()
                .multiplyScalar(collisionRadius)
                .sub(dist);
              state.mons[i].asset.position.add(push.clone().multiplyScalar(0.5));
              state.mons[j].asset.position.add(push.clone().multiplyScalar(-0.5));
            }
          }
        }

        for (let i = 0 ; i < state.mons.length; i++) {
          // keep inside bounds
          if (state.mons[i].asset.position.x > boundX) {
            state.mons[i].asset.position.x = boundX;
          } else if (state.mons[i].asset.position.x < -boundX) {
            state.mons[i].asset.position.x = -boundX;
          }
          if (state.mons[i].asset.position.z > boundZ) {
            state.mons[i].asset.position.z = boundZ;
          } else if (state.mons[i].asset.position.z < -boundZ) {
            state.mons[i].asset.position.z = -boundZ;
          }
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();
    }

    setupThreeJSScene();

    //let app = Elm.Main.init({
    //  node: document.getElementById('myapp'),
    //  flags: { initModel: monIndex, initCrunch: doCrunch }
    //});

    //app.ports.setCrunch.subscribe(function(b) {
    //  doCrunch = b;
    //});

    //app.ports.getModel.subscribe(async function(ix) {
    //  if (!gltfLoader) {
    //    alert("GLTF loader not yet ready");
    //    return;
    //  }
    //  if (!loadModel) {
    //    alert("loadModel not yet ready");
    //    return;
    //  }
    //  for (let i = 203; i < 260; i++) {
    //    await loadModel(scene, i);
    //  }
    //});
    for (let i = 203; i < 278; i++) {
      if (i >= 264 && i < 268) {
        continue;
      }
      await loadModel(scene, i);
    }
  </script>
</body>
</html>
